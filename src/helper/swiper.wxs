/* eslint-disable */

var swiperContainer = null
var swiperLiteItems = []
var startXY = [0, 0]
var startTime = 0
var offsetCache = [0, 0]
var noop = function () {}
var requestAnimationFrame = noop

var attrs = {}

var current = 0

var resistanceRatio = 0.5

function getSwiperContainer (instance) {
    return instance.selectComponent('.swiper-lite')
}

function getSwiperLiteItems (instance) {
    return instance.selectAllComponents('.swiper-lite-item')
}

// 计算边界抵抗后的偏移值
function resistance (offset, ratio) {
    return offset * ratio
}

function transformSwiper (offset, hooks) {
    hooks = hooks || {}
    if (hooks.before) hooks.before(offset)

    var offsetX = offset[0] || 0
    var offsetY = offset[1] || 0

    swiperContainer.setStyle({
        transform: 'translate(' + offsetX + 'px,' + offsetY + 'px)'
    })

    if (hooks.after) hooks.after(offset)
}

function isLimit (offset, dir) {
    var limit = attrs.width * (attrs.length - 1 + (attrs.circular ? 2 : 0)) * -1
    var mainOffset = offset[0]
    var mainDir = dir[0]

    if (attrs.vertical) {
        limit = attrs.height * (attrs.length - 1 + (attrs.circular ? 2 : 0)) * -1
        mainOffset = offset[1]
        mainDir = dir[1]
    }

    console.log('边界抵抗: ', mainOffset, limit)
    return (
        mainOffset === 0 && mainDir > 0
        || mainOffset === limit && mainDir < 0
    )
}

function createAnimationTransform(time, current, target) {
    var lastTime = 0
    var leftOffsetX = target[0]
    var leftOffsetY = target[1]

    function animation (onAnimationEnd) {
        onAnimationEnd = onAnimationEnd || noop
        var now = Date.now()
        if (lastTime <= 0) {
            lastTime = now
            animation(onAnimationEnd)
            return
        }

        requestAnimationFrame(function () {
            var duration = now - lastTime
            var animationTime = Math.min(1, (duration / time))
            var offsetX = (target[0] - current[0]) * animationTime
            var offsetY = (target[1] - current[1]) * animationTime

            transformSwiper([ current[0] + offsetX, current[1] + offsetY ], {
                after: function () {
                    leftOffsetX -= offsetX
                    leftOffsetY -= offsetY
                }
            })

            if (duration > time) {
                onAnimationEnd && onAnimationEnd()
            } else {
                animation(onAnimationEnd)
            }
        })
    }

    return animation
}

function touchstart (event, ownerInstance) {
    swiperContainer = getSwiperContainer(ownerInstance)
    swiperLiteItems = getSwiperLiteItems(ownerInstance)
    requestAnimationFrame = ownerInstance.requestAnimationFrame

    startTime = Date.now()
    var touch = event.touches[0]
    if (touch) {
        startXY = [ touch.pageX, touch.pageY ]
    }
}

function touchmove (event, ownerInstance) {
    var touch = event.touches[0]
    var offsetX = touch.pageX - startXY[0]
    var offsetY = touch.pageY - startXY[1]

    // 边界抵抗
    if (isLimit(offsetCache, [offsetX, offsetY])) {
        offsetX = resistance(offsetX, resistanceRatio)
        offsetY = resistance(offsetY, resistanceRatio)
    }

    var offset = attrs.vertical ? [ 0, offsetY ] : [ offsetX, 0 ]

    transformSwiper(offset, {
        before: function (offset) {
            offset[0] = offsetCache[0] + offset[0]
            offset[1] = offsetCache[1] + offset[1]
        }
    })

    ownerInstance.triggerEvent('transition', { dx: offsetX, dy: offsetY })
}

function changeCurrent (nextCurrent) {
    if (current !== nextCurrent) {
        if (attrs.circular) {
            swiperLiteItems[current + 1].removeClass('swiper-lite-current')
            swiperLiteItems[nextCurrent + 1].addClass('swiper-lite-current')
        } else {
            swiperLiteItems[current].removeClass('swiper-lite-current')
            swiperLiteItems[nextCurrent].addClass('swiper-lite-current')
        }

        current = nextCurrent
    }
}

function touchend (event, ownerInstance) {
    var touch = event.changedTouches[0]
    // 这里要重新计算，感觉是不是不太好
    var offsetX = touch.pageX - startXY[0]
    var offsetY = touch.pageY - startXY[1]
    var dx = offsetX
    var dy = offsetY

    var time = Date.now() - startTime
    var width = attrs.width
    var height = attrs.height
    
    var duration = 200

    // 边界回弹
    if (isLimit(offsetCache, [offsetX, offsetY])) {
        offsetX = resistance(offsetX, resistanceRatio)
        offsetY = resistance(offsetY, resistanceRatio)
        var offset = attrs.vertical ? [offsetCache[0], offsetCache[1] + offsetY] : [offsetCache[0] + offsetX, offsetCache[1]]
        createAnimationTransform(duration, offset, offsetCache)()
        return
    }

    var nextCurrent = current

    var mainOffset = attrs.vertical ? offsetY : offsetX
    if (attrs.vertical) {
        width = 0
        offsetX = 0
    } else {
        height = 0
        offsetY = 0
    }
    // 正常滑动
    if (
        Math.abs(mainOffset) > 200 ||
        Math.abs(mainOffset) / time >= 0.5
    ) {
        if (mainOffset > 0) {
            // 上一个
            nextCurrent = (nextCurrent + attrs.length - 1) % attrs.length

            createAnimationTransform(
                duration,
                [offsetCache[0] + offsetX, offsetCache[1] + offsetY],
                // TODO: 支持同时改变多个 Math.max(offsetX / width, 1)
                [offsetCache[0] + width, offsetCache[1] + height]
            )(function () {
                offsetCache[0] = offsetCache[0] + width
                offsetCache[1] = offsetCache[1] + height

                if (attrs.circular) {
                    if (current === 0) {
                        offsetCache[0] = attrs.length * width * -1
                        offsetCache[1] = attrs.length * height * -1
                        transformSwiper(offsetCache)
                    }
                }
                changeCurrent(nextCurrent)
                
                ownerInstance.triggerEvent('animationfinish', { dx: offsetX, dy: offsetY })
            })
        } else {
            nextCurrent = (nextCurrent + attrs.length + 1) % attrs.length

            // 下一个
            createAnimationTransform(
                duration,
                [offsetCache[0] + offsetX, offsetCache[1] + offsetY],
                [offsetCache[0] + width * -1, offsetCache[1] + height * -1]
            )(function () {
                offsetCache[0] = offsetCache[0] + width * -1
                offsetCache[1] = offsetCache[1] + height * -1

                if (attrs.circular) {
                    if (current === attrs.length - 1) {
                        offsetCache[0] = width * -1
                        offsetCache[1] = height * -1
                        transformSwiper(offsetCache)
                    }
                }
                changeCurrent(nextCurrent)

                ownerInstance.triggerEvent('animationfinish', { dx: dx, dy: dy })
            })
        }
    } else {
        createAnimationTransform(duration, [offsetCache[0] + offsetX, offsetCache[1] + offsetY], offsetCache)(function () {
            ownerInstance.triggerEvent('animationfinish', { dx: dx, dy: dy })
        })
    }

    ownerInstance.triggerEvent('change', { current: nextCurrent })
}

function attrsObserver (newValue, oldValue, ownerInstance) {
    swiperContainer = getSwiperContainer(ownerInstance)
    swiperLiteItems = getSwiperLiteItems(ownerInstance)

    attrs = newValue

    if (newValue.circular && oldValue && !oldValue.circular) {
        var offsets = attrs.vertical ? [ 0, attrs.height * -1 ] : [ attrs.width * -1 ]
        transformSwiper(offsets, {
            after: function () {
                if (attrs.vertical) {
                    offsetCache[1] = offsetCache[1] + attrs.height * -1
                } else {
                    offsetCache[0] = offsetCache[0] + attrs.width * -1
                }
            }
        })
    }
}

module.exports = {
    touchstart: touchstart,
    touchmove: touchmove,
    touchend: touchend,
    touchcancel: touchend,
    attrsObserver: attrsObserver
}