/* eslint-disable */

var swiperContainer = null
var swiperLiteItems = []
var startXY = [0, 0]
var startTime = 0
var offsetCache = [0, 0]
var noop = function () {}
var requestAnimationFrame = noop

var attrs = {}

var current = 0

var resistanceRatio = 0.5

// 计算边界抵抗后的偏移值
function resistance (offset, ratio) {
    return offset * ratio
}

function transformSwiper (offset, hooks) {
    hooks = hooks || {}
    if (hooks.before) hooks.before(offset)

    // for (var i = 0; i < swiperLiteItems.length; i++) {
    //     if (hooks.beforeEach) hooks.beforeEach(offset, i, swiperLiteItems[i])
    //
    //     var item = swiperLiteItems[i]
    //     if (item) {
    //         item.setStyle({
    //             transform: 'translate(' + offset[0] + 'px)'
    //         })
    //     }
    //
    //     if (hooks.afterEach) hooks.afterEach(offset, i, swiperLiteItems[i])
    // }

    swiperContainer.setStyle({
        transform: 'translate(' + offset[0] + 'px)'
    })

    if (hooks.after) hooks.after(offset)
}

function isLimit (offset, dir, limit) {
    return (
        offset[0] === 0 && dir[0] > 0
        || offset[0] === 0 && dir[0] > 0
    )
}

function createAnimationTransform(time, current, target) {
    var lastTime = 0
    var leftOffsetX = target[0]

    function animation (onAnimationEnd) {
        onAnimationEnd = onAnimationEnd || noop
        var now = Date.now()
        if (lastTime <= 0) {
            lastTime = now
            animation(onAnimationEnd)
            return
        }

        requestAnimationFrame(function () {
            var duration = now - lastTime
            var offsetX = (target[0] - current[0]) * Math.min(1, (duration / time))

            transformSwiper([ current[0] + offsetX ], {
                after: function () {
                    leftOffsetX -= offsetX
                }
            })

            if (duration > time) {
                onAnimationEnd && onAnimationEnd()
            } else {
                animation(onAnimationEnd)
            }
        })
    }

    return animation
}

function touchstart (event, ownerInstance) {
    swiperContainer = ownerInstance.selectComponent('.swiper-lite')
    swiperLiteItems = ownerInstance.selectAllComponents('.swiper-lite-item')
    requestAnimationFrame = ownerInstance.requestAnimationFrame
    startTime = Date.now()
    var touch = event.touches[0]
    if (touch) {
        startXY = [ touch.pageX, touch.pageY ]
    }
}

function touchmove (event, ownerInstance) {
    var touch = event.touches[0]
    var offsetX = touch.pageX - startXY[0]
    var width = event.currentTarget.dataset.width

    // current 0 边界抵抗
    if (isLimit(offsetCache, [offsetX])) {
        offsetX = resistance(offsetX, resistanceRatio)
    }

    transformSwiper([ offsetX ], {
        before: function (offset) {
            offset[0] = offsetCache[0] + offset[0]
        }
    })
}

function touchend (event, ownerInstance) {
    var touch = event.changedTouches[0]
    // 这里要重新计算，感觉是不是不太好
    var offsetX = touch.pageX - startXY[0]

    var time = Date.now() - startTime
    var width = attrs.width
    
    var duration = 200

    // 在边界回弹
    if (isLimit(offsetCache, [offsetX])) {
        offsetX = resistance(offsetX, resistanceRatio)
        createAnimationTransform(duration, [offsetCache[0] + offsetX], [offsetCache[0]])()
        return
    }

    var nextCurrent = current
    // 正常滑动
    if (
        Math.abs(offsetX) > 200 ||
        Math.abs(offsetX) / time >= 0.5
    ) {
        if (offsetX > 0) {
            createAnimationTransform(
                duration,
                [offsetCache[0] + offsetX],
                // TODO: 支持同时改变多个 Math.max(offsetX / width, 1)
                [offsetCache[0] + width]
            )(function () {
                offsetCache[0] = offsetCache[0] + width
            })

            nextCurrent -= 1
        } else {
            createAnimationTransform(
                duration,
                [offsetCache[0] + offsetX],
                [offsetCache[0] + width * -1]
            )(function () {
                offsetCache[0] = offsetCache[0] + width * -1
            })

            nextCurrent += 1
        }
    } else {
        createAnimationTransform(duration, [offsetCache[0] + offsetX], [offsetCache[0]])()
    }

    console.log(current, nextCurrent)
    if (current !== nextCurrent) {
        swiperLiteItems[current].removeClass('swiper-lite-current')
        swiperLiteItems[nextCurrent].addClass('swiper-lite-current')

        current = nextCurrent
    }
}

function attrsObserver (newValue, oldValue, ownerInstance) {
    swiperContainer = ownerInstance.selectComponent('.swiper-lite')
    swiperLiteItems = ownerInstance.selectAllComponents('.swiper-lite-item')

    attrs = newValue

    if (newValue.circular && oldValue && !oldValue.circular) {
        transformSwiper([ newValue.width * -1 ], {
            after: function () {
                offsetCache[0] = offsetCache[0] + newValue.width * -1
            }
        })
    }
}

module.exports = {
    touchstart: touchstart,
    touchmove: touchmove,
    touchend: touchend,
    touchcancel: touchend,
    attrsObserver: attrsObserver
}