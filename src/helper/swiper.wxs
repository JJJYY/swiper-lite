/* eslint-disable */

var swiperContainer = null
var swiperLiteItems = []
var startXY = [0, 0]
var startTime = 0
var offsetCache = [0, 0]
var noop = function () {}
var requestAnimationFrame = noop

var attrs = {}

var current = 0

var resistanceRatio = 0.5

function getSwiperContainer (instance) {
    return instance.selectComponent('.swiper-lite')
}

function getSwiperLiteItems (instance) {
    return instance.selectAllComponents('.swiper-lite-item')
}

// 计算边界抵抗后的偏移值
function resistance (offset, ratio) {
    return offset * ratio
}

function transformSwiper (offset, hooks) {
    hooks = hooks || {}
    if (hooks.before) hooks.before(offset)

    swiperContainer.setStyle({
        transform: 'translate(' + offset[0] + 'px)'
    })

    if (hooks.after) hooks.after(offset)
}

function isLimit (offset, dir) {
    var limit = attrs.width * (attrs.length - 1 + (attrs.circular ? 2 : 0)) * -1

    return (
        offset[0] === 0 && dir[0] > 0
        || offset[0] === limit && dir[0] < 0
    )
}

function createAnimationTransform(time, current, target) {
    var lastTime = 0
    var leftOffsetX = target[0]

    function animation (onAnimationEnd) {
        onAnimationEnd = onAnimationEnd || noop
        var now = Date.now()
        if (lastTime <= 0) {
            lastTime = now
            animation(onAnimationEnd)
            return
        }

        requestAnimationFrame(function () {
            var duration = now - lastTime
            var offsetX = (target[0] - current[0]) * Math.min(1, (duration / time))

            transformSwiper([ current[0] + offsetX ], {
                after: function () {
                    leftOffsetX -= offsetX
                }
            })

            if (duration > time) {
                onAnimationEnd && onAnimationEnd()
            } else {
                animation(onAnimationEnd)
            }
        })
    }

    return animation
}

function touchstart (event, ownerInstance) {
    swiperContainer = getSwiperContainer(ownerInstance)
    swiperLiteItems = getSwiperLiteItems(ownerInstance)
    requestAnimationFrame = ownerInstance.requestAnimationFrame

    startTime = Date.now()
    var touch = event.touches[0]
    if (touch) {
        startXY = [ touch.pageX, touch.pageY ]
    }
}

function touchmove (event, ownerInstance) {
    var touch = event.touches[0]
    var offsetX = touch.pageX - startXY[0]
    var offsetY = touch.pageY - startXY[1]

    // current 0 边界抵抗
    if (isLimit(offsetCache, [offsetX])) {
        offsetX = resistance(offsetX, resistanceRatio)
    }

    transformSwiper([ offsetX ], {
        before: function (offset) {
            offset[0] = offsetCache[0] + offset[0]
        }
    })

    ownerInstance.triggerEvent('animationfinish', { dx: offsetX, dy: offsetY })
}

function changeCurrent (nextCurrent) {
    console.log(current, nextCurrent, swiperLiteItems)
    if (current !== nextCurrent) {
        if (attrs.circular) {
            swiperLiteItems[current + 1].removeClass('swiper-lite-current')
            swiperLiteItems[nextCurrent + 1].addClass('swiper-lite-current')
        } else {
            swiperLiteItems[current].removeClass('swiper-lite-current')
            swiperLiteItems[nextCurrent].addClass('swiper-lite-current')
        }

        current = nextCurrent
    }
}

function touchend (event, ownerInstance) {
    var touch = event.changedTouches[0]
    // 这里要重新计算，感觉是不是不太好
    var offsetX = touch.pageX - startXY[0]
    var offsetY = touch.pageY - startXY[1]

    var time = Date.now() - startTime
    var width = attrs.width
    
    var duration = 200

    // 在边界回弹
    if (isLimit(offsetCache, [offsetX])) {
        offsetX = resistance(offsetX, resistanceRatio)
        createAnimationTransform(duration, [offsetCache[0] + offsetX], [offsetCache[0]])()
        return
    }

    var nextCurrent = current
    // 正常滑动
    if (
        Math.abs(offsetX) > 200 ||
        Math.abs(offsetX) / time >= 0.5
    ) {
        if (offsetX > 0) {
            // 上一个
            nextCurrent = (nextCurrent + attrs.length - 1) % attrs.length

            createAnimationTransform(
                duration,
                [offsetCache[0] + offsetX],
                // TODO: 支持同时改变多个 Math.max(offsetX / width, 1)
                [offsetCache[0] + width]
            )(function () {
                offsetCache[0] = offsetCache[0] + width

                if (attrs.circular) {
                    if (current === 0) {
                        offsetCache[0] = attrs.length * attrs.width * -1
                        transformSwiper([ offsetCache[0] ])
                    }
                }
                changeCurrent(nextCurrent)
                
                ownerInstance.triggerEvent('animationfinish', { dx: offsetX, dy: offsetY })
            })
        } else {
            nextCurrent = (nextCurrent + attrs.length + 1) % attrs.length

            // 下一个
            createAnimationTransform(
                duration,
                [offsetCache[0] + offsetX],
                [offsetCache[0] + width * -1]
            )(function () {
                offsetCache[0] = offsetCache[0] + width * -1

                if (attrs.circular) {
                    if (current === attrs.length - 1) {
                        offsetCache[0] = width * -1
                        transformSwiper([ offsetCache[0] ])
                    }
                }
                changeCurrent(nextCurrent)

                ownerInstance.triggerEvent('animationfinish', { dx: offsetX, dy: offsetY })
            })
        }
    } else {
        createAnimationTransform(duration, [offsetCache[0] + offsetX], [offsetCache[0]])(function () {
            ownerInstance.triggerEvent('animationfinish', { dx: offsetX, dy: offsetY })
        })
    }

    ownerInstance.triggerEvent('change', { current: nextCurrent })
}

function attrsObserver (newValue, oldValue, ownerInstance) {
    swiperContainer = getSwiperContainer(ownerInstance)
    swiperLiteItems = getSwiperLiteItems(ownerInstance)

    attrs = newValue

    if (newValue.circular && oldValue && !oldValue.circular) {
        transformSwiper([ newValue.width * -1 ], {
            after: function () {
                offsetCache[0] = offsetCache[0] + newValue.width * -1
            }
        })
    }
}

module.exports = {
    touchstart: touchstart,
    touchmove: touchmove,
    touchend: touchend,
    touchcancel: touchend,
    attrsObserver: attrsObserver
}